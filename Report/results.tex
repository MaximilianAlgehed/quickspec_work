\section{Results}\label{results}

In order to compare the performance of the different methods
a set of benchmarks have been established. The benchmarks favour
large signatures to even out the effects of randomness on runtime.

\begin{tabular}{|l|l|l|}
    \hline
    Benchmark                       & Integer arithmetic & Lists \\ \hline
    TE hand $\mu$                   & 147s               & 10.5s \\ \hline
    TE hand $\sigma$                & 8.6                & 0.3  \\ \hline
    TE \texttt{suchThat} $\mu$      & 189s               & 10.5s \\ \hline
    TE \texttt{suchThat} $\sigma$   & 22.3               & 0.3  \\ \hline
    FE $\mu$                        & $>$30m             & 22.4s \\ \hline
    FE $\sigma^2$                   & N/A                & 1.2  \\ \hline
\end{tabular}

At 30 minuites function encoding still had
40 000 equations left to test or prune in the Integer arithmetic benchmark.
The results presented for the List benchmark are based on 100 executions
of each implementation.
The results presented for the Integer arithmetic benchmark are based
on 20 executions of each implementation, function encoding not included as execution
time exceeded 30 minuites.

A sample of equations generated by function encoding that can not be parsed as conditional
equations with the relevant predicates
\begin{verbatim}
min (whenPositive i) (whenPositive j) = whenPositive (min i j)
zip (whenNotNull is) (sort is) = zip is (sort is)
whenNotNull (is ++ reverse is) = is ++ reverse (whenNotNull is)
whenNegative (fst (whenNotEqual i (-1))) = whenNegative i
\end{verbatim}
