\section{Expressivity}

A question which naturally arises when studying the
definitions in section \ref{encodings} is;
Can every equation that is expressed in a specific encoding
scheme really be translated into a conditional equation?
The answer to this question, sadly, is no. The semantics
for how one would translate a function encoding or a combined
encoding to a conditional are not as obvious as one would think.
Consider the following example:
\begin{verbatim}
%Example involving whenBitZeroZero (whenBitSevenZero b) = whenBitSevenZero (whenBitZeroZero b)
%which shows that if we choose repeated application of different predicates
%to mean conjunction of predicates we get problems with
%whenSorted (whenNotNull xs) = f xs
%which can't be translated to
%(whenSorted xs) and (whenNotNull xs) => xs = f xs
\end{verbatim}

The coulprit here is surely the choice of default value for our function encodings. 
In section \ref{combined_encoding} we introduced the idea of combined encoding which was meant to do away
with issues like this. However, as we see in the following example
the semanitcs for combined encoding are not clear either:
\begin{verbatim}
%some example of when multiple applications of a ce function
%destroys the property whenP (f x) = (g x)
\end{verbatim}

These examples clearly illustrate the need to be explicit about conjunctions
and mappings of data. It is apparent that what advantage function
and combined encoding had over type encoding in terms of expressing
predicates of mappings or conjunction of predicates is lost.
Furthermore we now need to consider the extra overhead that is introduced
when we have to, for each equation generated in a function or combined
encoding setting, consider if an equation can actually be rewritten
as a conditional equation.
