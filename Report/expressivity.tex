\section{Expressivity}

Function encoding can sometimes lead to non-results. Consider this interesting side effect of the way function encoding
works
\begin{verbatim}-- All elements greater than 0
greater :: [Integer] -> Bool

-- All elements less than 0 
lesser :: [Integer] -> Bool

-- A function encoding of greater
whenGreater :: [Integer] -> [Integer]
whenGreater xs
    | greater xs = xs
    | otherwise  = [1]

-- A function encoding of lesser 
whenLesser :: [Integer] -> [Integer]
whenLesser xs
    | lesser xs = xs
    | otherwise = [-1]\end{verbatim}
Given this QuickSpec will happily generate equations like
\begin{verbatim}(whenLesser (whenGreater xs)) = [-1]\end{verbatim}
which, if we take $whenP\circ whenQ$ to mean $P(x)\wedge Q(x)$,  translates to the riddiculous\\
$\forall xs : List\; Integer.\; greater(xs)\wedge lesser(xs)\implies xs = Cons\; (-1)\; Nil$.
Which is actually just\\$\forall xs : List\; Integer.\; False\implies xs = Cons\; (-1)\; Nil$,
or put simply\\$p\vee \neg p$.

When looking at the definition in 
section \ref{encodings} it is easy to assume
that function encoding is highly expressive.
An assumption one is tempted to make is that
function encoding can handle conditional (highly contrived)
equations like this\\
$\forall xs : List.\;sorted\;(tail\; xs) \implies insert\;(head\;xs)\;(tail\;xs)=sort\;xs$.
However, as we will see there are several limitations to what function encoding can express.
If we analyze the equation above we find that QuickSpec will indeed not find it
using function encoding as easily as we would have hoped.
\begin{verbatim}-- Function encoding of sorted lists
whenSorted :: [Integer] -> Bool
whenSorted xs
    | sorted xs = xs
    | otherwise = []

let xs = [2, 2, 1, 3]

-- Now we get the following
sort xs = [1, 2, 2, 3]
insert (head xs) (whenSorted (tail xs)) = [2]\end{verbatim}
Here we see that function encoding will rule the implication out as false. The approach is
incomplete for these types of equations.

Function encoding has the potential to produce unparsable equations.
There is nothing in the semantics of Haskell that stops us from getting function
encoded equations like
\begin{verbatim}whenP x (whenQ y) = g (whenP (f y) (h x))\end{verbatim}
In the space of all predicates $P$ and $Q$, as well as all functions $f$, $g$, and $h$ it
is not inconveciable that the above expression can not be translated to a constrained
equation on the form\\$"Something\;with\;variables,\;P,\;and\;Q"\implies "Something\;with\;variables,\;f,\;g,\;and\;h"$.
One may argue that the equation still has a meaning, but it is at the very best a side track
from the original theory we are trying to investigate and ultimately is a distraction from the goal.
We would like our representation of conditional equations to be opaque but the expression above
can not be parsed in any meaningfull way without knowing something about the function symbols involved.

For type encoding however we can always produce a conditional equation given a few constraints.
These constraints are the following
\begin{itemize}
    \item For every predicate type \texttt{PredicateP} representing an arity N predicate \texttt{P}
        there are N functions such that \texttt{funX :: PredicateP -> TypeOfArgXOfP}.
    \item For every \texttt{p :: PredicateP} the following holds \texttt{P (fun1 p) (fun2 p) ... (funN p) == True}.
    \item Somehow state that the functions are not something like \texttt{funX = const k} unless they have to be.
\end{itemize}
Of course, these conditions are rather optimistic. It may well be likely that QuickSpec will find that "all sorted lists
are of length less than five million", simply because it does not test lists of length grater than some number in a typical
run. However, the conditional equation generated by type encoding is still "sound modulo QuickSpec"; it will not generate
conditional equations which are not parsable or false. %I am aware this section is "thin" in terms of content...
