\section{Completeness}

As QuickSpec limits the size
of the equations it considers, size being
defined as the number of function symbols in the
equation it is worth considering the impact that
different encodings have on the size of the equations 
and how that relates to completeness. In both
function encoding and type encoding we use two
symbols to express every occurance of
a constrained variable. However, in
combined encoding we need to use three symbols
to refer to any one occurance of a constrained variable.
Due to this, without support for combined encoding in
QuickSpec the approach loses out on many equations which
it's less verbose siblings are able to handle.

For this result to be valid the function encoding representation
of predicates of arity greater than one must be something similar to
\texttt{whenP :: (A, B, C) -> (A, B, C)}. However, this means that
function encoding may not automatically find conjunctions (represented as
the higher arity equivalient of \texttt{whenP . whenQ}) of predicates
as easily as it will for arity one predicates. In order to combat this
one could choose to add the constructors for n-tuples to the signature. This,
of course, means that we now have a larger signature full of auxilleary functions
which we are not interested in.
