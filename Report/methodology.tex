\section{Methodology}
There are several factors by which we measure the quality of our different methods.
The primary qualities are:

\begin{itemize}

    \item Soundness
    \item Completeness
    \item Generality
    \item Opaque function symbols

\end{itemize}

In addition to these concrete qualities the overall efficiency of the different methods are also
taken in to account.
We chose these qualities as they all increase the usefullness
of QuickSpec both as a standalone theory exploration tool
and as a component of other tools.

    \subsection{Soundness}
    If QuickSpec generates unsound conjectures, systems that use QuickSpec
    need to spend resources trying to prove conjectures that are false. Furthermore
    a user using QuickSpec to infer knowledge about some library (like in the many
    good examples from the case studies in the first paper on QuickSpec) could easily
    be misled by false conjectures.

    \subsection{Completeness}
    As the purpose of using QuickSpec in a theory exploration setting is to discover
    new and interesting lemmas, it is obvious that a more expressive QuickSpec means a more
    complete theory. %some reference on completeness or something...
    Completeness is of interest for the reason pointed out in the first paper on QuickSpec; %QuickSpec 1 paper reference
    missing equations tell the user as much about the systems as the equations which are
    present. For this reason, the higher the degree of completeness the higher the usefullness
    of QuickSpec as a stand-alone tool. 

    \subsection{Generality}
    Without a general method for generating the representation of conditionals
    it is hard to see how the functionality would be usefull in an automated setting.
    Furthermore QuickSpec is meant as a light weight tool, without a general method
    for conditional equations the overhead for the user will be big and the feature
    is unlikely to be utilized.

    \subsection{Opaque function symbols}
    Working with the whole haskell language in QuickSpec quickly becomes unweildy.
    If the haskell language can be sufficiently abstracted to predicates, types, and
    equations this allows for several elegant solutions to common problems. One
    example is the Knuth-Bendix completion used in the QuickSpec pruner, because
    completion is based entierly on rewrite rules it does not have to consider
    the semantic meaning of functions (unlike inductive provers). Furthermore
    opaque function symbols in theory allow QuickSpec to be used to test
    pure C functions through haskell's foreign function interface, as QuickSpec does
    not need to know the definition of the functions.
