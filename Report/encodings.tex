\section{Different encodings}\label{encodings}

    This section describes three
    ways of encoding conditional
    equations in QuickSpec. It is
    worth noting that these methods
    are general and could be used outside
    the context of QuickSpec. The
    idea of encoding conditionals
    as types is something users of
    QuickCheck \cite{Claessen2000}
    are familiar with
    \footnote{The QuickCheck distribution
    on hackage, \texttt{https://hackage.haskell.org/package/QuickCheck}, includes for an instance an implementation
    of the \texttt{NonNegative} type.}. 
    This work presents two alternative methods
    to type encoding. First however, we present type encoding
    in more detail.

    \subsection{Type encoding}\label{TE}

        Type encoding is the idea of encoding
        predicates as dependent types. More specifically
        it is saying that for a given predicate
        \begin{verbatim}
        p :: (a, b, c, ... , x) -> Bool
        \end{verbatim}
        there exists a dependent type
        \begin{verbatim}
        Predicate p
        \end{verbatim}
        and a function 
        \begin{verbatim}
        data :: Predicate p -> (a, b, c, ... , x)
        \end{verbatim}
        such that 
        \begin{verbatim}
        p . data = const True
        \end{verbatim}
        This may seem odd when you consider that haskell is not a dependently types
        language. However, as QuickSpec uses QuickCheck, which lets us define
        custom generators for random data, we can write a generator for 
        the predicate type which makes the type behaves like a dependent type.
        This means that when equations involving these predicate
        types are tested by QuickCheck the types behave as if they were dependent types.
        The equations involving predicate types are on the form
        \begin{verbatim}
        f (data p) = g (data p)
        \end{verbatim}
        which translates to $p(x) \implies f(x) = g(x)$.

        In this encoding we would have to be explicit about things such as conjunction
        of multiple predicates or predicates of mappings of data.
        Being explicit about these things induces more overhead, therefore
        we want to find a light weight encoding scheme. Motivated by this
        we introduce function encoding.

        As we are looking for a general method for encoding predicates we need
        a way to automatically generate the instances of the \texttt{Arbitrary} type class.
        The naive way of doing this is to use the
        \texttt{suchThat}\footnote{\texttt{https://hackage.haskell.org/package/QuickCheck-2.8.2/docs/Test-QuickCheck-Gen.html}} 
        combinator. 

    \subsection{Function encoding}

        Function encoding is the idea of encoding 
        predicates with functions. The idea is best
        illustrated with an example
        \begin{verbatim}
        -- p is a predicate
        p :: (a, b, c, ... , x) -> Bool

        -- default is a value such that
        p default = True

        -- The predicate is encoded as
        when_p :: (a, b, c, ... , x) -> (a, b, c, ... , x)
        when_p input
            | p input   = input
            | otherwise = data default
        \end{verbatim}
        In function encoding, an equation like
        \begin{verbatim}
        g (when_p x) == f (when_p x)
        \end{verbatim}
        would be equivalent to the aformentioned $p(x) \implies f(x) = g(x)$.
        Some care needs to be taken when choosing the default value.
        With combined encoding we do not need to make that decision ourselves.

     \subsection{Combined encoding}\label{combined_encoding}
        
        Combined encoding is the idea that we can let the
        default value of a function encoded predicate be a type
        encoding of the predicate. A combined encoding can be illustrated
        like this
        \begin{verbatim}
        -- p is a predicate
        p :: (a, b, c, ..., x) -> Bool  

        -- when_p is a combined encoding of p
        when_p :: Predicate p -> (a, b, c, ... , x) -> (a, b, c, ... , x)
        when_p default input
            | p input   = input
            | otherwise = default
        \end{verbatim}
        The encoding of $p(x) \implies f(x) = g(x)$ in combined encoding would look like
        this
        \begin{verbatim}
        f (when_p p x) == g (when_p p x)
        \end{verbatim}
