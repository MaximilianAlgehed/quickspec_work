~Conditional Lemma Discovery and Resurcion Induction in Hipster

~people.mpi-inf.mpg.de/~dwand/datasup/draft.pdf
    Automatic Induction inside Superposition

-- Pros and cons of different methods for encoding constraints --

    ~Two possible methods:

        ~Function encoding: (FE)

            Make a function that converts data to a format where a predicate always holds
            
            Questions:

                What does this approach really mean?

            Possible problems:
                Adding more functions that work over the same type as the rest of the program

                The problem is that adding max and min to describe the relationship (x >= y)
                means that we end up with a theory for max and min

            How would we express "x Greater than y and y positive" in FE?

        ~Type encoding: (TE)

            Create types that are instantiated such that the predicate always holds

            Positive result:
                Giving quickcheck the insert (as in insertion sort) function, a type for 
                generating a pair of numbers (x, y) where x > y, and the basic list implementation
                (nil and cons) generates this rather exciting output in almost no time:

                    insert i [] = i:[]
                    insert x (y:is) = y:(insert x is)
                    insert y (x:is) = y:x:is

            Possible problems:
                Complex relationships involving the same variable can be hard to encode

            Question to investigate:
                If we have the type Greater and the type Pos, how do we express:
                    x Greater than y and y Pos ?

                    Figuring this out would allow quickspec to find like:
                    x > y && y > 0 => x > 1

                In the insert example ("test2.hs"), if you add sorted, true, and false. You get some strange behavior.
                It would be good to investigate if inserting the sorted list predicate type here would improve
                the quality of the output. Why doesn't this work, what is the problem?

        ~Things to figure out:
            
            TE and FE for partial functions, find good examples of this.

        ~Comparison of TE and FE:

            In Type encoding (TE) we introduce a new type and a function which simply lifts from that type.
            In Function encoding (FE) we introduce a function which works on the same type as the rest of the
            theory. A problem I have encountered when not using any background theory etc is that TE is able to
            handle a maxTermSize of 10 for smaller theories without problem. However FE fails at size 10 when doing something
            as simple as encoding (x >= y) using max and min. The reason for this seems to be that quickspec
            is busy generating the theory for max and min when we are not really interested in that theory.

            FE is in a way less obvious and more obtuse a method to encode predicates than TE. 
            Say we want to encode the property x < y. We cannot do this with the functions min and max as:

                x <= y -> min x y = x
                and likewise for max

            However it is very simple to encode both strictly less than and less than or equal in the TE scheme.
            And importantly it is easy to differentiate between them.

            A major advantage of the TE scheme is that the predicates are _explicit_.

        ~Problems with these methods:
            
            They introduce overhead, quite alot of overhead

            They are both bad at modelling complex relationships

        ~Conversion from FE to TE:

            In the predicate logic example we find that replacing the unary predicate valid
            with the suitable type Tautology we find that we don't get the overhead of the theory of tautologies.

            Similarily we find that the theory of sorted lists can be replaced by a type for sorted lists.

            In fact any unary predicate over some type T:
                
                predicate :: T -> Bool

            Can be modelled as a type:

                data Predicate = Predicate T

                instance Arbitrary where
                    arbitrary = return . Predicate =<< arbitrary `suchThat` predicate

            This gives us a conversion from unary FE to unary TE.

            Similary for a binary predicate over any two types T and T':

                predicate :: T -> T' -> Bool

            Can be modelled as the type:

                data Predicate = Predicate T T'

                instance Arbitrary Predicate where
                    arbitrary = 
                                do
                                    t <- arbitrary
                                    t' <- arbitrary `suchThat` predicate
                                    return (Predicate T T')

            It is important to note that this construction allows encoding of a predicate as a type, in the sense that
            it let's us constuct propositions like P(x) -> E, or !P(x) -> E, where E is an expression (or in the case of
            quickspec an equality). However, it does not let us discover neat laws about the predicate.
