~Conditional Lemma Discovery and Resurcion Induction in Hipster

~people.mpi-inf.mpg.de/~dwand/datasup/draft.pdf
    Automatic Induction inside Superposition

-- Pros and cons of different methods for encoding constraints --

    ~Two possible methods:

        ~Function encoding: (FE)

            Make a function that converts data to a format where a predicate always holds

            Tricky for predicates of arity > 1

            One solution for arity > 1 is to do something like:
                fun :: a -> b -> (a, b)
            The problem with this is that now we have to add fst and snd to our
            signature, and it's not very general.

            Questions:

                What does this approach really mean?

            Possible problems:
                Adding more functions that work over the same type as the rest of the program
                means we slow the program down. 

                It is not obvious how to find a good representative of a predicate in FE that
                does not result in the whole expression being boolean valued.

        ~Type encoding: (TE)

            Create types that are instantiated such that the predicate always holds

            Positive result:
                Giving quickcheck the insert (as in insertion sort) function, a type for 
                generating a pair of numbers (x, y) where x > y, and the basic list implementation
                (nil and cons) generates this rather exciting output in almost no time:

                    insert i [] = i:[]
                    insert x (y:is) = y:(insert x is)
                    insert y (x:is) = y:x:is

            Possible problems:
                Complex relationships involving the same variable can be hard to encode

            Question to investigate:
                Conjunction of predicates!
                Disjunction of predicates is the same as getting multiple equations? yes/no?

        ~Things to figure out:
            
            TE and FE for partial functions, find good examples of this.
            Conjunction of predicates in TE.

        ~Comparison of TE and FE:

            In Type encoding (TE) we introduce a new type and a function which simply lifts from that type.
            In Function encoding (FE) we introduce a function which works on the same type as the rest of the
            theory. A problem I have encountered when not using any background theory etc is that TE is able to
            handle a maxTermSize of 10 for smaller theories without problem. However FE fails at size 10 when doing something
            as simple as encoding (x >= y) using max and min. The reason for this seems to be that quickspec
            is busy generating the theory for max and min when we are not really interested in that theory.

            FE is in a way less obvious and more obtuse a method to encode predicates than TE. 
            Say we want to encode the property x < y. We cannot do this with the functions min and max as:

                x <= y -> min x y = x
                and likewise for max

            However it is very simple to encode both strictly less than and less than or equal in the TE scheme.
            And importantly it is easy to differentiate between them.

            Another issue with FE is that when we introduce functions of higher airity (e.g. max and min) to 
            encode the predicates we get exponential blowup. Especially as we increase the maxTermSize.

            A comparison of having max versus having Greater for encoding the relation >=, both in the "foreground" theory:
                With max for insert with size 7:
                    1609 events 
                with max for insert with size 9:
                    33000 events
                With Greater for insert with size 7:
                    990 events
                With Greater for insert with size 9:
                    11000 events

            FE deals "well" with the conjunction of predicates, but it is a very hard problem!:
                
                P x && Q x => x <*> y = ...
                gets encoded as
                (Q'. P') x <*> y = ...
                where P' and Q' are the functions that compute the "representative" of x
                under the conditions P and Q.
                However one would need to be very carefull when construction the functions
                Q' and P'. To see an example of how difficult this is notice:
                    
                    Q = not . null
                    P = sorted

                The naive implementation of Q' and P' would be:

                    Q' = whenNotNull
                    whenNotNull [] = [x] -- for some "representative" x
                    whenNotNull xs = xs

                    P' = whenSorted
                    whenSorted xs 
                        | isSorted xs = xs
                        | otherwise = []

                The problem is, what if we were to choose whenNotNull [] = [2, 1].
                Now we have whenSorted . whenNotNull /= whenNotNull . whenSorted.
                Also, the result isnt sorted!!!

                This is not a problem with this example, as [2, 1] is a truly bad choice of 
                representative. But if we have something like:

                    allNumbersInListLessThanZero

                    and

                    allNumersInListGreaterThanZeroOrZero

                Now we don't have any implementation of whenNotNull that does not exclude
                one predicate or the other.

            As for how we can do conjunciton of predicates in TE:

                Just construct more types, one for each combination of predicates.
                This is also bad, as in we get exponential blowup.
            
        ~Problems with these methods:
            
            They introduce overhead, quite alot of overhead

            They are both bad at modelling complex relationships

        ~Conversion from FE to TE:

            In the predicate logic example we find that replacing the unary predicate valid
            with the suitable type Tautology we find that we don't get the overhead of the theory of tautologies.

            Similarily we find that the theory of sorted lists can be replaced by a type for sorted lists.

            In fact any unary predicate over some type T:
                
                predicate :: T -> Bool

            Can be modelled as a type:

                data Predicate = Predicate T

                instance Arbitrary where
                    arbitrary = return . Predicate =<< arbitrary `suchThat` predicate

            This gives us a conversion from unary FE to unary TE.

            Similary for a binary predicate over any two types T and T':

                predicate :: T -> T' -> Bool

            Can be modelled as the type:

                data Predicate = Predicate T T'

                instance Arbitrary Predicate where
                    arbitrary = 
                                do
                                    t <- arbitrary
                                    t' <- arbitrary `suchThat` predicate
                                    return (Predicate t t')

            It is important to note that this construction allows encoding of a predicate as a type, in the sense that
            it let's us constuct propositions like P(x) -> E, or !P(x) -> E, where E is an expression (or in the case of
            quickspec an equality). However, it does not let us discover neat laws about the predicate.

        ~List of topics:

            *TE
            
            *FE

            *Conjunction

            *Disjunction
